(full_cond)
}
#p_sig(ST = sig, sig_sq = 8, .mu = c(0,0,0))
#p_sig2(ST = sig, sig_sq = 8, .mu = c(0,0,0))
library(dplyr)
library(truncnorm)
cor2cov <- function(cor.mat,vars) {
mat <- matrix(rep(sqrt(vars), length(vars)), nrow = length(vars))
cor.mat * mat * t(mat)
}
makeCov <- function(cors,vars) {
cor.mat <- diag(length(vars))
cor.mat[upper.tri(cor.mat)] <- cor.mat[lower.tri(cor.mat)] <- cors
mat <- matrix(rep(sqrt(vars), length(vars)), nrow = length(vars))
cor.mat * mat * t(mat)
}
met_gibbs <- function(its) {
sd_sig <- 0.5
sd_rho <- 0.1
# For sigma, use truncated normal as proposal
propose_sig <- function(x, mn) {
#browser()
log(dtruncnorm(x, a = 0, mean = mn, sd = sd_sig))
}
propose_rho <- function(x, mn) {
log(dtruncnorm(x, a = -1, b = 1, mean = mn, sd = sd_rho))
}
met_mu <- matrix(NA, its, 3)
met_mu[1,] <- rep(0, 3)
mat_sig <- matrix(NA, nrow = its, ncol = 3)
mat_rho <- matrix(NA, nrow = its, ncol = 3)
mat_sig[1,] <- c(1, 4, 9)#rep(1, 3)
mat_rho[1,] <- rep(0 , 3) #12, 13, 23
a_sig <- rep(0, 3)
a_rho <- rep(0, 3)
for(i in 2:its) {
#sample mu with mvn
#sample sigma given mu
#sample rho given sigma and mu & rtruncnorm between (-1,1)
cov <- makeCov(mat_rho[i-1,], mat_sig[i-1,])
#browser()
met_mu[i,] <- p_mu(ST = cov) #Done sampling mu
### SIGMA ###
for(j in 1:3) {
candidate_sig <- rtruncnorm(
1, a = 0, mean = mat_sig[i-1,j], sd = sd_sig
)
if(j == 1){candidate_sig = 1}
if(j == 2){candidate_sig = 4}
if(j == 3){candidate_sig = 9}
cand.sig.vec <- diag(cov)
cand.sig.vec[j] <- candidate_sig
cov2 <- makeCov(mat_rho[i-1,], cand.sig.vec)
ratio_sig <-
( p_sig(ST = cov2, sig_sq = candidate_sig, .mu = met_mu[i,]) -
propose_sig(candidate_sig, mn = cov[j,j]) ) -
( p_sig(ST = cov, sig_sq = cov[j,j], .mu = met_mu[i,]) -
propose_sig(cov[j,j], mn = candidate_sig) )
pmove <- min(0, ratio_sig)
#if(is.na(pmove)) browser()
u <- log(runif(1))
if(u < pmove) {
mat_sig[i,j] <- candidate_sig
#cov2[j,j] <- candidate_sig
a_sig[j] <- a_sig[j] + 1
cov <- cov2
}
else {
mat_sig[i,j] <- mat_sig[i-1,j]
}
}
### RHO ###
cor_to_cov3 <- c(
sqrt(mat_sig[i,1] * mat_sig[i,2]),
sqrt(mat_sig[i,1] * mat_sig[i,3]),
sqrt(mat_sig[i,2] * mat_sig[i,3])
) #convert correlation to covariance
#browser()
for(k in 1:3) {
candidate_rho <- rtruncnorm(
1, a = -1, b = 1, mean = mat_rho[i-1,k], sd = sd_rho
)
cor <- cov2cor(cov)
cand.rho.vec <- cor[upper.tri(cor)]
cand.rho.vec[k] <- candidate_rho
cov3 <- makeCov(cand.rho.vec, mat_sig[i,])
ratio_cov <-
(p_rho(rho = candidate_rho, .mu = met_mu[i,], ST = cov3) -
propose_rho(candidate_rho, mn = mat_rho[i-1,k])) -
(p_rho(rho = mat_rho[i-1,k], .mu = met_mu[i,], ST = cov) -
propose_rho(mat_rho[i-1,k], mn = candidate_rho))
#if(is.na(ratio_cov)) browser()
pmove <- min(0, ratio_cov)
u <- log(runif(1))
if(u < pmove) {
mat_rho[i,k] <- candidate_rho
a_rho[k] <- a_rho[k] + 1
cov <- cov3
}
else {
mat_rho[i,k] <- mat_rho[i-1,k]
}
chol(cov)
#browser()
}
}
list(met_mu, mat_sig, mat_rho, a_sig, a_rho, cov2cor(cov))
}
its <- 1000
a <- met_gibbs(its = its)
colMeans(a[[1]])
colMeans(a[[2]])
colMeans(a[[3]])
matplot(a[[1]], type = "l")
matplot((a[[2]]), type = "l")
matplot(a[[3]], type = "l")
a[[4]]/its
a[[5]]/its
.cov <- a[[6]]; .cov
eigen(.cov)
library(dplyr)
library(truncnorm)
cor2cov <- function(cor.mat,vars) {
mat <- matrix(rep(sqrt(vars), length(vars)), nrow = length(vars))
cor.mat * mat * t(mat)
}
makeCov <- function(cors,vars) {
cor.mat <- diag(length(vars))
cor.mat[upper.tri(cor.mat)] <- cor.mat[lower.tri(cor.mat)] <- cors
mat <- matrix(rep(sqrt(vars), length(vars)), nrow = length(vars))
cor.mat * mat * t(mat)
}
met_gibbs <- function(its) {
sd_sig <- 0.5
sd_rho <- 0.2
# For sigma, use truncated normal as proposal
propose_sig <- function(x, mn) {
#browser()
log(dtruncnorm(x, a = 0, mean = mn, sd = sd_sig))
}
propose_rho <- function(x, mn) {
log(dtruncnorm(x, a = -1, b = 1, mean = mn, sd = sd_rho))
}
met_mu <- matrix(NA, its, 3)
met_mu[1,] <- rep(0, 3)
mat_sig <- matrix(NA, nrow = its, ncol = 3)
mat_rho <- matrix(NA, nrow = its, ncol = 3)
mat_sig[1,] <- c(1, 4, 9)#rep(1, 3)
mat_rho[1,] <- rep(0 , 3) #12, 13, 23
a_sig <- rep(0, 3)
a_rho <- rep(0, 3)
for(i in 2:its) {
#sample mu with mvn
#sample sigma given mu
#sample rho given sigma and mu & rtruncnorm between (-1,1)
cov <- makeCov(mat_rho[i-1,], mat_sig[i-1,])
#browser()
met_mu[i,] <- p_mu(ST = cov) #Done sampling mu
### SIGMA ###
for(j in 1:3) {
candidate_sig <- rtruncnorm(
1, a = 0, mean = mat_sig[i-1,j], sd = sd_sig
)
if(j == 1){candidate_sig = 1}
if(j == 2){candidate_sig = 4}
if(j == 3){candidate_sig = 9}
cand.sig.vec <- diag(cov)
cand.sig.vec[j] <- candidate_sig
cov2 <- makeCov(mat_rho[i-1,], cand.sig.vec)
ratio_sig <-
( p_sig(ST = cov2, sig_sq = candidate_sig, .mu = met_mu[i,]) -
propose_sig(candidate_sig, mn = cov[j,j]) ) -
( p_sig(ST = cov, sig_sq = cov[j,j], .mu = met_mu[i,]) -
propose_sig(cov[j,j], mn = candidate_sig) )
pmove <- min(0, ratio_sig)
#if(is.na(pmove)) browser()
u <- log(runif(1))
if(u < pmove) {
mat_sig[i,j] <- candidate_sig
#cov2[j,j] <- candidate_sig
a_sig[j] <- a_sig[j] + 1
cov <- cov2
}
else {
mat_sig[i,j] <- mat_sig[i-1,j]
}
}
### RHO ###
cor_to_cov3 <- c(
sqrt(mat_sig[i,1] * mat_sig[i,2]),
sqrt(mat_sig[i,1] * mat_sig[i,3]),
sqrt(mat_sig[i,2] * mat_sig[i,3])
) #convert correlation to covariance
#browser()
for(k in 1:3) {
candidate_rho <- rtruncnorm(
1, a = -1, b = 1, mean = mat_rho[i-1,k], sd = sd_rho
)
cor <- cov2cor(cov)
cand.rho.vec <- cor[upper.tri(cor)]
cand.rho.vec[k] <- candidate_rho
cov3 <- makeCov(cand.rho.vec, mat_sig[i,])
ratio_cov <-
(p_rho(rho = candidate_rho, .mu = met_mu[i,], ST = cov3) -
propose_rho(candidate_rho, mn = mat_rho[i-1,k])) -
(p_rho(rho = mat_rho[i-1,k], .mu = met_mu[i,], ST = cov) -
propose_rho(mat_rho[i-1,k], mn = candidate_rho))
#if(is.na(ratio_cov)) browser()
pmove <- min(0, ratio_cov)
u <- log(runif(1))
if(u < pmove) {
mat_rho[i,k] <- candidate_rho
a_rho[k] <- a_rho[k] + 1
cov <- cov3
}
else {
mat_rho[i,k] <- mat_rho[i-1,k]
}
chol(cov)
#browser()
}
}
list(met_mu, mat_sig, mat_rho, a_sig, a_rho, cov2cor(cov))
}
its <- 1000
a <- met_gibbs(its = its)
colMeans(a[[1]])
colMeans(a[[2]])
colMeans(a[[3]])
matplot(a[[1]], type = "l")
matplot((a[[2]]), type = "l")
matplot(a[[3]], type = "l")
a[[4]]/its
a[[5]]/its
.cov <- a[[6]]; .cov
eigen(.cov)
library(dplyr)
library(truncnorm)
cor2cov <- function(cor.mat,vars) {
mat <- matrix(rep(sqrt(vars), length(vars)), nrow = length(vars))
cor.mat * mat * t(mat)
}
makeCov <- function(cors,vars) {
cor.mat <- diag(length(vars))
cor.mat[upper.tri(cor.mat)] <- cor.mat[lower.tri(cor.mat)] <- cors
mat <- matrix(rep(sqrt(vars), length(vars)), nrow = length(vars))
cor.mat * mat * t(mat)
}
met_gibbs <- function(its) {
sd_sig <- 0.5
sd_rho <- 0.3
# For sigma, use truncated normal as proposal
propose_sig <- function(x, mn) {
#browser()
log(dtruncnorm(x, a = 0, mean = mn, sd = sd_sig))
}
propose_rho <- function(x, mn) {
log(dtruncnorm(x, a = -1, b = 1, mean = mn, sd = sd_rho))
}
met_mu <- matrix(NA, its, 3)
met_mu[1,] <- rep(0, 3)
mat_sig <- matrix(NA, nrow = its, ncol = 3)
mat_rho <- matrix(NA, nrow = its, ncol = 3)
mat_sig[1,] <- c(1, 4, 9)#rep(1, 3)
mat_rho[1,] <- rep(0 , 3) #12, 13, 23
a_sig <- rep(0, 3)
a_rho <- rep(0, 3)
for(i in 2:its) {
#sample mu with mvn
#sample sigma given mu
#sample rho given sigma and mu & rtruncnorm between (-1,1)
cov <- makeCov(mat_rho[i-1,], mat_sig[i-1,])
#browser()
met_mu[i,] <- p_mu(ST = cov) #Done sampling mu
### SIGMA ###
for(j in 1:3) {
candidate_sig <- rtruncnorm(
1, a = 0, mean = mat_sig[i-1,j], sd = sd_sig
)
if(j == 1){candidate_sig = 1}
if(j == 2){candidate_sig = 4}
if(j == 3){candidate_sig = 9}
cand.sig.vec <- diag(cov)
cand.sig.vec[j] <- candidate_sig
cov2 <- makeCov(mat_rho[i-1,], cand.sig.vec)
ratio_sig <-
( p_sig(ST = cov2, sig_sq = candidate_sig, .mu = met_mu[i,]) -
propose_sig(candidate_sig, mn = cov[j,j]) ) -
( p_sig(ST = cov, sig_sq = cov[j,j], .mu = met_mu[i,]) -
propose_sig(cov[j,j], mn = candidate_sig) )
pmove <- min(0, ratio_sig)
#if(is.na(pmove)) browser()
u <- log(runif(1))
if(u < pmove) {
mat_sig[i,j] <- candidate_sig
#cov2[j,j] <- candidate_sig
a_sig[j] <- a_sig[j] + 1
cov <- cov2
}
else {
mat_sig[i,j] <- mat_sig[i-1,j]
}
}
### RHO ###
cor_to_cov3 <- c(
sqrt(mat_sig[i,1] * mat_sig[i,2]),
sqrt(mat_sig[i,1] * mat_sig[i,3]),
sqrt(mat_sig[i,2] * mat_sig[i,3])
) #convert correlation to covariance
#browser()
for(k in 1:3) {
candidate_rho <- rtruncnorm(
1, a = -1, b = 1, mean = mat_rho[i-1,k], sd = sd_rho
)
cor <- cov2cor(cov)
cand.rho.vec <- cor[upper.tri(cor)]
cand.rho.vec[k] <- candidate_rho
cov3 <- makeCov(cand.rho.vec, mat_sig[i,])
ratio_cov <-
(p_rho(rho = candidate_rho, .mu = met_mu[i,], ST = cov3) -
propose_rho(candidate_rho, mn = mat_rho[i-1,k])) -
(p_rho(rho = mat_rho[i-1,k], .mu = met_mu[i,], ST = cov) -
propose_rho(mat_rho[i-1,k], mn = candidate_rho))
#if(is.na(ratio_cov)) browser()
pmove <- min(0, ratio_cov)
u <- log(runif(1))
if(u < pmove) {
mat_rho[i,k] <- candidate_rho
a_rho[k] <- a_rho[k] + 1
cov <- cov3
}
else {
mat_rho[i,k] <- mat_rho[i-1,k]
}
chol(cov)
#browser()
}
}
list(met_mu, mat_sig, mat_rho, a_sig, a_rho, cov2cor(cov))
}
its <- 1000
a <- met_gibbs(its = its)
a <- met_gibbs(its = its)
recover()
eigen(cor)
eigen(cov)
eigen(cor)
eigen(cov)
library(dplyr)
library(truncnorm)
cor2cov <- function(cor.mat,vars) {
mat <- matrix(rep(sqrt(vars), length(vars)), nrow = length(vars))
cor.mat * mat * t(mat)
}
makeCov <- function(cors,vars) {
cor.mat <- diag(length(vars))
cor.mat[upper.tri(cor.mat)] <- cor.mat[lower.tri(cor.mat)] <- cors
mat <- matrix(rep(sqrt(vars), length(vars)), nrow = length(vars))
cor.mat * mat * t(mat)
}
met_gibbs <- function(its) {
sd_sig <- 0.5
sd_rho <- 0.2
# For sigma, use truncated normal as proposal
propose_sig <- function(x, mn) {
#browser()
log(dtruncnorm(x, a = 0, mean = mn, sd = sd_sig))
}
propose_rho <- function(x, mn) {
log(dtruncnorm(x, a = -1, b = 1, mean = mn, sd = sd_rho))
}
met_mu <- matrix(NA, its, 3)
met_mu[1,] <- rep(0, 3)
mat_sig <- matrix(NA, nrow = its, ncol = 3)
mat_rho <- matrix(NA, nrow = its, ncol = 3)
mat_sig[1,] <- c(1, 4, 9)#rep(1, 3)
mat_rho[1,] <- rep(0 , 3) #12, 13, 23
a_sig <- rep(0, 3)
a_rho <- rep(0, 3)
for(i in 2:its) {
#sample mu with mvn
#sample sigma given mu
#sample rho given sigma and mu & rtruncnorm between (-1,1)
cov <- makeCov(mat_rho[i-1,], mat_sig[i-1,])
#browser()
met_mu[i,] <- p_mu(ST = cov) #Done sampling mu
### SIGMA ###
for(j in 1:3) {
candidate_sig <- rtruncnorm(
1, a = 0, mean = mat_sig[i-1,j], sd = sd_sig
)
if(j == 1){candidate_sig = 1}
if(j == 2){candidate_sig = 4}
if(j == 3){candidate_sig = 9}
cand.sig.vec <- diag(cov)
cand.sig.vec[j] <- candidate_sig
cov2 <- makeCov(mat_rho[i-1,], cand.sig.vec)
ratio_sig <-
( p_sig(ST = cov2, sig_sq = candidate_sig, .mu = met_mu[i,]) -
propose_sig(candidate_sig, mn = cov[j,j]) ) -
( p_sig(ST = cov, sig_sq = cov[j,j], .mu = met_mu[i,]) -
propose_sig(cov[j,j], mn = candidate_sig) )
pmove <- min(0, ratio_sig)
#if(is.na(pmove)) browser()
u <- log(runif(1))
if(u < pmove) {
mat_sig[i,j] <- candidate_sig
#cov2[j,j] <- candidate_sig
a_sig[j] <- a_sig[j] + 1
cov <- cov2
}
else {
mat_sig[i,j] <- mat_sig[i-1,j]
}
}
### RHO ###
cor_to_cov3 <- c(
sqrt(mat_sig[i,1] * mat_sig[i,2]),
sqrt(mat_sig[i,1] * mat_sig[i,3]),
sqrt(mat_sig[i,2] * mat_sig[i,3])
) #convert correlation to covariance
#browser()
for(k in 1:3) {
candidate_rho <- rtruncnorm(
1, a = -1, b = 1, mean = mat_rho[i-1,k], sd = sd_rho
)
cor <- cov2cor(cov)
cand.rho.vec <- cor[upper.tri(cor)]
cand.rho.vec[k] <- candidate_rho
cov3 <- makeCov(cand.rho.vec, mat_sig[i,])
ratio_cov <-
(p_rho(rho = candidate_rho, .mu = met_mu[i,], ST = cov3) -
propose_rho(candidate_rho, mn = mat_rho[i-1,k])) -
(p_rho(rho = mat_rho[i-1,k], .mu = met_mu[i,], ST = cov) -
propose_rho(mat_rho[i-1,k], mn = candidate_rho))
#if(is.na(ratio_cov)) browser()
pmove <- min(0, ratio_cov)
u <- log(runif(1))
if(u < pmove) {
mat_rho[i,k] <- candidate_rho
a_rho[k] <- a_rho[k] + 1
cov <- cov3
}
else {
mat_rho[i,k] <- mat_rho[i-1,k]
}
chol(cov)
#browser()
}
}
list(met_mu, mat_sig, mat_rho, a_sig, a_rho, cov2cor(cov))
}
its <- 1000
a <- met_gibbs(its = its)
colMeans(a[[1]])
colMeans(a[[2]])
colMeans(a[[3]])
matplot(a[[1]], type = "l")
matplot((a[[2]]), type = "l")
matplot(a[[3]], type = "l")
a[[4]]/its
a[[5]]/its
.cov <- a[[6]]; .cov
eigen(.cov)
library(dplyr)
dat <- read.csv("data.csv")
dat2 <- dat[,-1]
y <- dat[,"y"]
X <- dat[,-c(1,2)] %>% as.matrix()
X <- cbind(1, X)
nrow(X) # n
ncol(X) # p = 11, p + 1 = 12
p_sig <- function(a = 1, b = 1, n = nrow(X), beta) {
a_term <- a + (n/2)
b_term <- 0.5 * (2*b + (t(y - (X %*% beta)) %*% (y - (X %*% beta)))) #y, X defined above
1 / rgamma(1, shape = a_term, rate = 1/b_term)
}
library(mvtnorm)
p_beta <- function(sig_sq, tau_sq = 1, p = ncol(X)) {
sig <- solve( (sig_sq * diag(p) ) + (tau_sq * t(X) %*% X))
mu <- tau_sq * (sig) %*% t(X) %*% y
#browser()
rmvnorm(1, mean = mu, sigma = sig)
}
set.seed(12)
gibbs <- function(its, p = ncol(X)) {
mat_beta <- matrix(NA, its, p)
mat_sig <- rep(NA, its)
mat_sig[1] <- 1
mat_beta[1,] <- rep(0, p)
for(i in 2:its) {
mat_beta[i,] <- p_beta(sig_sq = mat_sig[i-1])
#browser()
mat_sig[i] <- p_sig(beta = mat_beta[i,])
}
list(mat_beta, mat_sig)
}
its <- 1000
a <- gibbs(its = its)
matplot(a[[1]], type = "l", main = "Plot of Beta vs. Iterations")
plot(a[[2]], type = "l", main = "Plot of sigma^2 vs. Iterations")
#matplot(a[[1]][,c(2,3,11)], type = "l")
tail(a[[2]])
mod <- lm(y ~ ., data = dat2)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (nrow(X) - (ncol(X) - 1) - 1) #or just 1000 - 12
s_sq #same ting from summary table
summary(mod)$sigma^2 #from summary table
mean(a[[2]])
colMeans(a[[1]])
mod$coefficients
