p_sig <- function(a = 0, b = 0, X, beta) {
n <- nrow(X)
a_term <- a + (n/2)
b_term <- 0.5 * (2*b + (t(y - (X %*% beta)) %*% (y - (X %*% beta))))
1 / rgamma(1, shape = a_term, rate = b_term)
}
p_beta <- function(sig_sq, tau_sq = 1000, X) {
p = ncol(X)-1
sig <- solve( (1/sig_sq) * (t(X) %*% X) + (1/tau_sq) * diag(p+1) )
mu <- (1/sig_sq) * sig %*% t(X) %*% y
rmvnorm(1, mean = mu, sigma = sig)
}
bhat <- function(sig_sq, tau_sq = 1000, X) {
p = ncol(X)-1
sig <- solve( (1/sig_sq) * (t(X) %*% X) + (1/tau_sq) * diag(p+1) )
mu <- (1/sig_sq) * sig %*% t(X) %*% y
mu
}
met_gibbs <- function(its) {
mat_t <- matrix(NA, its, nknot)
mat_t[1,] <- rep(0, nknot)
## INITIALIZE X_curr ##
X_curr <- matrix(NA, nknot, length(x))
s <- sample(1, nknot, replace = TRUE)
for(i in 1:nknot) {
for(j in 1:length(x)) {
X_curr[i,j] <- max(s[i] * (x[j] - mat_t[1,i]), 0)
} #creating basis
} #X Matrix
X_curr <- t(X_curr); X_curr <- cbind(1, X_curr)
mat_beta <- matrix(NA, its, ncol(X_curr))
mat_sig <- rep(NA, its)
mat_sig[1] <- 0.01
mat_beta[1,] <- rep(0, ncol(X_curr))
ar <- 0
for(it in 2:its) {
propose_t <- function(x) {
log(dunif(x, 0, 1))
}
candidate_t <- runif(nknot, 0, 1)
### CREATE BASIS FUNCTIONS FROM THIS t-vector  ###
s <- sample(1, nknot, replace = TRUE)
X_cand <- matrix(NA, nknot, length(x))
for(i in 1:nknot) {
for(j in 1:length(x)) {
X_cand[i,j] <- max(s[i] * (x[j] - candidate_t[i]), 0)
} #creating basis
} #X Matrix
X_cand <- t(X_cand)
X_cand <- cbind(1, X_cand)
ratio <-
(p_t(sig_sq = mat_sig[it-1], betahat = bhat(mat_sig[it-1], X = X_cand), X = X_cand)
- propose_t(candidate_t)) -
(p_t(sig_sq = mat_sig[it-1], betahat = bhat(mat_sig[it-1], X = X_curr), X = X_curr)
- propose_t(mat_t[it-1,]))
accept_prob <- min(0, ratio)
u <- log(runif(1))
browser()
if(u < accept_prob) {
ar <- ar + 1
mat_t[it,] <- candidate_t
X_curr <- X_cand
} else {
mat_t[it,] <- mat_t[it-1,]
}
mat_beta[it,] <- p_beta(sig_sq = mat_sig[it-1], X = X_curr)
mat_sig[it] <- p_sig(beta = mat_beta[it,], X = X_curr)
}
list(mat_beta, mat_sig, mat_t, X_curr, ar)
}
its <- 3000
a <- met_gibbs(its = its)
mat_beta <- a[[1]] #beta values
mat_sig <- a[[2]] #sig^2 values
mat_t <- a[[3]]
X_curr <- a[[4]]
ar <- a[[5]]
list(mat_beta, mat_sig, mat_t, X_curr, ar)
}
mcmc_spline()
u
ratio
p_t(sig_sq = mat_sig[it-1], betahat = bhat(mat_sig[it-1], X = X_cand), X = X_cand)
propose_t(candidate_t)
propose_t(mat_t[it-1,])
p_t(sig_sq = mat_sig[it-1], betahat = bhat(mat_sig[it-1], X = X_curr), X = X_curr)
65048-453178
ar
i
it
j
length(x)
knitr::opts_chunk$set(echo = TRUE)
set.seed(12)
n<-300
x<-seq(0,1,length.out=n)
y<-sin(2*pi*x^2)*10+rnorm(n)
plot(x,y)
library(mvtnorm)
mcmc_spline <- function(nknot = 5) {
p_t <- function(sig_sq, betahat, X) {
(-1/(2*sig_sq)) * t(y - (X %*% betahat)) %*% (y - (X %*% betahat))
}
p_sig <- function(a = 0, b = 0, X, beta) {
n <- nrow(X)
a_term <- a + (n/2)
b_term <- 0.5 * (2*b + (t(y - (X %*% beta)) %*% (y - (X %*% beta))))
1 / rgamma(1, shape = a_term, rate = b_term)
}
p_beta <- function(sig_sq, tau_sq = 1000, X) {
p = ncol(X)-1
sig <- solve( (1/sig_sq) * (t(X) %*% X) + (1/tau_sq) * diag(p+1) )
mu <- (1/sig_sq) * sig %*% t(X) %*% y
rmvnorm(1, mean = mu, sigma = sig)
}
bhat <- function(sig_sq, tau_sq = 1000, X) {
p = ncol(X)-1
sig <- solve( (1/sig_sq) * (t(X) %*% X) + (1/tau_sq) * diag(p+1) )
mu <- (1/sig_sq) * sig %*% t(X) %*% y
mu
}
met_gibbs <- function(its) {
mat_t <- matrix(NA, its, nknot)
mat_t[1,] <- rep(0, nknot)
## INITIALIZE X_curr ##
X_curr <- matrix(NA, nknot, length(x))
s <- sample(1, nknot, replace = TRUE)
for(i in 1:nknot) {
for(j in 1:length(x)) {
X_curr[i,j] <- max(s[i] * (x[j] - mat_t[1,i]), 0)
} #creating basis
} #X Matrix
X_curr <- t(X_curr); X_curr <- cbind(1, X_curr)
mat_beta <- matrix(NA, its, ncol(X_curr))
mat_sig <- rep(NA, its)
mat_sig[1] <- 0.01
mat_beta[1,] <- rep(0, ncol(X_curr))
ar <- 0
for(it in 2:its) {
propose_t <- function(x) {
log(dunif(x, 0, 1))
}
candidate_t <- runif(nknot, 0, 1)
### CREATE BASIS FUNCTIONS FROM THIS t-vector  ###
s <- sample(1, nknot, replace = TRUE)
X_cand <- matrix(NA, nknot, length(x))
for(i in 1:nknot) {
for(j in 1:length(x)) {
X_cand[i,j] <- max(s[i] * (x[j] - candidate_t[i]), 0)
} #creating basis
} #X Matrix
X_cand <- t(X_cand)
X_cand <- cbind(1, X_cand)
ratio <-
(p_t(sig_sq = mat_sig[it-1], betahat = bhat(mat_sig[it-1], X = X_cand), X = X_cand)
- propose_t(candidate_t)) -
(p_t(sig_sq = mat_sig[it-1], betahat = bhat(mat_sig[it-1], X = X_curr), X = X_curr)
- propose_t(mat_t[it-1,]))
accept_prob <- min(0, ratio)
u <- log(runif(1))
#browser()
if(u < accept_prob) {
ar <- ar + 1
mat_t[it,] <- candidate_t
X_curr <- X_cand
} else {
mat_t[it,] <- mat_t[it-1,]
}
mat_beta[it,] <- p_beta(sig_sq = mat_sig[it-1], X = X_curr)
mat_sig[it] <- p_sig(beta = mat_beta[it,], X = X_curr)
}
list(mat_beta, mat_sig, mat_t, X_curr, ar)
}
its <- 3000
a <- met_gibbs(its = its)
mat_beta <- a[[1]] #beta values
mat_sig <- a[[2]] #sig^2 values
mat_t <- a[[3]]
X_curr <- a[[4]]
ar <- a[[5]]
list(mat_beta, mat_sig, mat_t, X_curr, ar)
}
mcmc_spline()
browser()
knitr::opts_chunk$set(echo = TRUE)
n<-300
x<-seq(0,1,length.out=n)
y<-sin(2*pi*x^2)*10+rnorm(n)
plot(x,y)
knotnum <- 5
its = 3000
source("mcmc_spline_fixed.R")
res <- mcmc_spline(knotnum)
mat_beta <- res[[1]]
mat_sig <- res[[2]]
mat_t <- res[[3]]
X_curr <- res[[4]]
ar <- res[[5]]
colMeans(mat_beta)
colMeans(mat_t)
mean(mat_sig)
ar
matplot(mat_beta, type = "l", main = "Plot of Regression Coefficients")
plot(mat_sig, type = "l", main = "Plot of Sigma^2")
matplot(mat_t, type = "l", main = "Plot of Knot Locations")
mean.pred <- matrix(NA, nrow = its, ncol = length(x))
pred <- mean.pred
for(p in 1:its) {
mean.pred[p,] <- spline.basis(nknot = knotnum, knots = mat_t[p,]) %*% mat_beta[p,]
pred[p,] <- mean.pred[p,] + rnorm(length(x), sd = sqrt(mat_sig[p]))
}
mean.pred <- t(mean.pred)
pred_adj <- t(apply(pred, 2, quantile, probs = c(0.025, 0.975)))
matplot(x, pred_adj, col = "lightgrey", lwd = 6, type = "l")
matplot(x, mean.pred, type = "l", lwd = 3, add = TRUE)
points(x, y)
plot(x, rowMeans(mean.pred), lwd = 10, type = "l", col = "royalblue")
points(x, y)
knitr::opts_chunk$set(echo = TRUE)
n<-300
x<-seq(0,1,length.out=n)
y<-sin(2*pi*x^2)*10+rnorm(n)
plot(x,y)
knotnum <- 9
its = 3000
source("mcmc_spline_fixed.R")
res <- mcmc_spline(knotnum)
mat_beta <- res[[1]]
mat_sig <- res[[2]]
mat_t <- res[[3]]
X_curr <- res[[4]]
ar <- res[[5]]
colMeans(mat_beta)
colMeans(mat_t)
mean(mat_sig)
ar
matplot(mat_beta, type = "l", main = "Plot of Regression Coefficients")
plot(mat_sig, type = "l", main = "Plot of Sigma^2")
matplot(mat_t, type = "l", main = "Plot of Knot Locations")
mean.pred <- matrix(NA, nrow = its, ncol = length(x))
pred <- mean.pred
for(p in 1:its) {
mean.pred[p,] <- spline.basis(nknot = knotnum, knots = mat_t[p,]) %*% mat_beta[p,]
pred[p,] <- mean.pred[p,] + rnorm(length(x), sd = sqrt(mat_sig[p]))
}
mean.pred <- t(mean.pred)
pred_adj <- t(apply(pred, 2, quantile, probs = c(0.025, 0.975)))
matplot(x, pred_adj, col = "lightgrey", lwd = 6, type = "l")
matplot(x, mean.pred, type = "l", lwd = 3, add = TRUE)
points(x, y)
plot(x, rowMeans(mean.pred), lwd = 10, type = "l", col = "royalblue")
points(x, y)
knitr::opts_chunk$set(echo = TRUE)
n<-300
x<-seq(0,1,length.out=n)
y<-sin(2*pi*x^2)*10+rnorm(n)
plot(x,y)
knotnum <- 5
its = 3000
source("mcmc_spline_fixed.R")
res <- mcmc_spline(knotnum)
mat_beta <- res[[1]]
mat_sig <- res[[2]]
mat_t <- res[[3]]
X_curr <- res[[4]]
ar <- res[[5]]
colMeans(mat_beta)
colMeans(mat_t)
mean(mat_sig)
ar
matplot(mat_beta, type = "l", main = "Plot of Regression Coefficients")
plot(mat_sig, type = "l", main = "Plot of Sigma^2")
matplot(mat_t, type = "l", main = "Plot of Knot Locations")
mean.pred <- matrix(NA, nrow = its, ncol = length(x))
pred <- mean.pred
for(p in 1:its) {
mean.pred[p,] <- spline.basis(nknot = knotnum, knots = mat_t[p,]) %*% mat_beta[p,]
pred[p,] <- mean.pred[p,] + rnorm(length(x), sd = sqrt(mat_sig[p]))
}
mean.pred <- t(mean.pred)
pred_adj <- t(apply(pred, 2, quantile, probs = c(0.025, 0.975)))
matplot(x, pred_adj, col = "lightgrey", lwd = 6, type = "l")
matplot(x, mean.pred, type = "l", lwd = 3, add = TRUE)
points(x, y)
knitr::opts_chunk$set(echo = TRUE)
n<-300
x<-seq(0,1,length.out=n)
y<-sin(2*pi*x^2)*10+rnorm(n)
plot(x,y)
knotnum <- 5
its = 3000
source("mcmc_spline_fixed.R")
res <- mcmc_spline(knotnum)
res <- mcmc_spline(knotnum)
res <- mcmc_spline(knotnum)
knitr::opts_chunk$set(echo = TRUE)
n<-300
x<-seq(0,1,length.out=n)
y<-sin(2*pi*x^2)*10+rnorm(n)
plot(x,y)
knotnum <- 5
its = 3000
source("mcmc_spline_fixed.R")
res <- mcmc_spline(knotnum)
mat_beta <- res[[1]]
mat_sig <- res[[2]]
mat_t <- res[[3]]
X_curr <- res[[4]]
ar <- res[[5]]
mat_s <- res[[6]]
colMeans(mat_beta)
colMeans(mat_t)
mean(mat_sig)
ar
matplot(mat_beta, type = "l", main = "Plot of Regression Coefficients")
plot(mat_sig, type = "l", main = "Plot of Sigma^2")
matplot(mat_t, type = "l", main = "Plot of Knot Locations")
mean.pred <- matrix(NA, nrow = its, ncol = length(x))
pred <- mean.pred
for(p in 1:its) {
mean.pred[p,] <- spline.basis(nknot = knotnum, knots = mat_t[p,], signs = mat_s[p,]) %*% mat_beta[p,]
pred[p,] <- mean.pred[p,] + rnorm(length(x), sd = sqrt(mat_sig[p]))
}
mean.pred <- t(mean.pred)
pred_adj <- t(apply(pred, 2, quantile, probs = c(0.025, 0.975)))
matplot(x, pred_adj, col = "lightgrey", lwd = 6, type = "l")
matplot(x, mean.pred, type = "l", lwd = 3, add = TRUE)
points(x, y)
plot(x, rowMeans(mean.pred), lwd = 10, type = "l", col = "royalblue")
points(x, y)
v <- rep(9, 8)
v
t(v)
t(t(v))
v <- rep(1, 9)
v
t(t(v))
knitr::opts_chunk$set(echo = TRUE)
set.seed(12)
n<-300
x<-seq(0,1,length.out=n)
y<-sin(2*pi*x^2)*10+rnorm(n)
plot(x,y)
generate_spline <- function(tvec, y, x, nknot = length(tvec)) {
s <- sample(c(1), nknot, replace = TRUE)
Bmat <- matrix(NA, nknot, length(x))
hs <- Bmat
for(i in 1:nknot) {
for(j in 1:length(x)) {
Bmat[i,j] <- max(s[i] * (x[j] - tvec[i]), 0)
} #creating basis functions
}
mBmat <- t(Bmat)
mod <- lm(y ~ mBmat) #use gibbs to sample coefs in bayes
pred <- predict(mod)
sq <- x
for(ii in 1:nknot) {
if(s[i] == 1) {
hs[ii,] <- sq - tvec[ii]
hs[ii,][sq < tvec[ii]] <- 0
}
else {
hs[ii,] <- -1*(sq - tvec[ii])
hs[ii,][sq < tvec[ii]] <- 0
}
} #setting x values
plot(x,y, main = "Manual Basis Spline")
lines(x, pred, type = "l", lwd = 5, col="blue1")
summary(mod)
}
tv <- c(0, 0.525, 0.865) #vector of t-values
generate_spline(tv, y = y, x = x)
library(mvtnorm)
bayes_spline <- function(tvec, y, x, nknot = length(tvec)) {
s <- sample(c(1), nknot, replace = TRUE)
Bmat <- matrix(NA, nknot, length(x))
hs <- Bmat
for(i in 1:nknot) {
for(j in 1:length(x)) {
Bmat[i,j] <- max(s[i] * (x[j] - tvec[i]), 0)
} #creating basis
} #X Matrix
X <- t(Bmat)
X <- cbind(1, X)
p_sig <- function(a = 0, b = 0, n = nrow(X), beta) {
a_term <- a + (n/2)
b_term <- 0.5 * (2*b + (t(y - (X %*% beta)) %*% (y - (X %*% beta)))) #y, X defined above
1 / rgamma(1, shape = a_term, rate = b_term)
}
p_beta <- function(sig_sq, tau_sq = 1000, p = ncol(X)-1) {
sig <- solve( (1/sig_sq) * (t(X) %*% X) + (1/tau_sq) * diag(p+1) )
mu <- (1/sig_sq) * sig %*% t(X) %*% y
rmvnorm(1, mean = mu, sigma = sig)
}
gibbs <- function(its) {
mat_beta <- matrix(NA, its, ncol(X))
mat_sig <- rep(NA, its)
mat_sig[1] <- 0.01
mat_beta[1,] <- rep(0, ncol(X))
for(it in 2:its) {
mat_beta[it,] <- p_beta(sig_sq = mat_sig[it-1])
mat_sig[it] <- p_sig(beta = mat_beta[it,])
}
list(mat_beta, mat_sig)
}
its <- 3000
a <- gibbs(its = its)
mat_beta <- a[[1]] #beta values
mat_sig <- a[[2]] #sig^2 values
list(mat_beta, mat_sig, X)
}
bayesian <- bayes_spline(c(0, 0.525, 0.865), y = y, x = x)
mat_beta <- bayesian[[1]]
mat_sig <- bayesian[[2]]
X <- bayesian[[3]]
burn <- 1:15
colMeans(mat_beta[-burn,]) #target: -1.83, 25.19, -91.23, 135.03
mean(mat_sig[-burn]) #target: 1.46
mean.pred <- X %*% t(mat_beta)
matplot(x, mean.pred, type = "l")
points(x,y)
pred <- t(mean.pred) + rnorm(300*2985,sd=sqrt(mat_sig)) #mean: X %*% beta
hist(X[100,] %*% t(mat_beta) + rnorm(2985,sd=sqrt(mat_sig))) #prediction
matplot(x,t(pred), type='l', col='lightgrey')
matplot(x,mean.pred, type='l', col='green', add=T)
points(x,y)
t1 <- 0.5 #knot at 0.5
s <- 1
B1 <- rep(NA, length(x))
for(i in 1:length(x)) {
B1[i] <- max(s * (x[i] - t1), 0)
}
mod <- lm(y ~ x + B1)
summary(mod)
cf <- mod$coefficients
sq <- x
hs <- sq - t1
hs[sq < t1] <- 0
yfit <- cf[1] + cf[2]*x + cf[3]*hs
plot(x,y, main = "Manual Basis Spline")
lines(x, yfit, type = "l", lwd = 5, col="navy")
source('~/Desktop/LANL/Git/LANL-CCS-6/Bayes_splines/mcmc_spline_rj.R')
det(diag(8))
source('~/Desktop/LANL/Git/LANL-CCS-6/Bayes_splines/mcmc_spline_rj.R')
factorial(4)
factorial
as.matrix(rep(9,9))
sample(c(1,2,3))
sample(c(1,2,3), 1)
sample(c(1,2,3), 1)
sample(c(1,2,3), 1)
sample(c(1,2,3), 1)
sample(c(1,2,3), 1, prob = 1/3)
sample(3, 1)
sample(3, 1)
sample(3, 1)
sample(3, 1)
rep(sample(3, 1), 100)
sample(3, 100)
sample(3, 100, replace = TRUE)
sample(3, 100, replace = TRUE)
sample(3, 100, replace = TRUE)
sample(3, 100, replace = TRUE)
sample(3, 100, replace = TRUE)
hist(sample(3, 10000, replace = TRUE))
hist(sample(3, 100, replace = TRUE))
hist(sample(3, 100, replace = TRUE))
hist(sample(3, 100, replace = TRUE))
hist(sample(3, 100, replace = TRUE))
knitr::opts_chunk$set(echo = TRUE)
n<-300
x<-seq(0,1,length.out=n)
y<-sin(2*pi*x^2)*10+rnorm(n)
plot(x,y)
knotnum <- 5
its = 3000
source("mcmc_spline_fixed.R")
res <- mcmc_spline(knotnum)
mat_beta <- res[[1]]
mat_sig <- res[[2]]
mat_t <- res[[3]]
X_curr <- res[[4]]
ar <- res[[5]]
mat_s <- res[[6]]
colMeans(mat_beta)
colMeans(mat_t)
mean(mat_sig)
ar
matplot(mat_beta, type = "l", main = "Plot of Regression Coefficients")
plot(mat_sig, type = "l", main = "Plot of Sigma^2")
matplot(mat_t, type = "l", main = "Plot of Knot Locations")
mean.pred <- matrix(NA, nrow = its, ncol = length(x))
pred <- mean.pred
for(p in 1:its) {
mean.pred[p,] <- spline.basis(nknot = knotnum, knots = mat_t[p,], signs = mat_s[p,]) %*% mat_beta[p,]
pred[p,] <- mean.pred[p,] + rnorm(length(x), sd = sqrt(mat_sig[p]))
}
mean.pred <- t(mean.pred)
pred_adj <- t(apply(pred, 2, quantile, probs = c(0.025, 0.975)))
matplot(x, pred_adj, col = "lightgrey", lwd = 6, type = "l")
matplot(x, mean.pred, type = "l", lwd = 3, add = TRUE)
points(x, y)
plot(x, rowMeans(mean.pred), lwd = 10, type = "l", col = "royalblue")
points(x, y)
sample(2:9, 1)
sample(2:9, 1)
sample(2:9, 1)
sample(2:9, 1)
sample(2:9, 1)
sample(2:9, 1)
sample(2:9, 1)
sample(2:9, 1)
