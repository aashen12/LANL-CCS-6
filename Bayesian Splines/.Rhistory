hs <- Bmat
for(i in 1:nknot) {
for(j in 1:length(x)) {
Bmat[i,j] <- max(s[i] * (x[j] - tvec[i]), 0)
} #creating basis functions
}
mBmat <- t(Bmat)
mod <- lm(y ~ mBmat) #use gibbs to sample coefs in bayes
pred <- predict(mod)
sq <- x
for(ii in 1:nknot) {
if(s[i] == 1) {
hs[ii,] <- sq - tvec[ii]
hs[ii,][sq < tvec[ii]] <- 0
}
else {
hs[ii,] <- -1*(sq - tvec[ii])
hs[ii,][sq < tvec[ii]] <- 0
}
} #setting x values
plot(x,y, main = "Manual Basis Spline")
lines(x, pred, type = "l", lwd = 5, col="blue1")
summary(mod)
}
tv <- c(0, 0.525, 0.865) #vector of t-values
generate_spline(tv, y = y, x = x)
library(mvtnorm)
bayes_spline <- function(tvec, y, x, nknot = length(tvec)) {
s <- sample(c(1), nknot, replace = TRUE)
Bmat <- matrix(NA, nknot, length(x))
hs <- Bmat
for(i in 1:nknot) {
for(j in 1:length(x)) {
Bmat[i,j] <- max(s[i] * (x[j] - tvec[i]), 0)
} #creating basis
} #X Matrix
X <- t(Bmat)
X <- cbind(1, X)
p_sig <- function(a = 0, b = 0, n = nrow(X), beta) {
a_term <- a + (n/2)
b_term <- 0.5 * (2*b + (t(y - (X %*% beta)) %*% (y - (X %*% beta)))) #y, X defined above
1 / rgamma(1, shape = a_term, rate = b_term)
}
p_beta <- function(sig_sq, tau_sq = 1000, p = ncol(X)-1) {
sig <- solve( (1/sig_sq) * (t(X) %*% X) + (1/tau_sq) * diag(p+1) )
mu <- (1/sig_sq) * sig %*% t(X) %*% y
rmvnorm(1, mean = mu, sigma = sig)
}
gibbs <- function(its) {
mat_beta <- matrix(NA, its, ncol(X))
mat_sig <- rep(NA, its)
mat_sig[1] <- 0.01
mat_beta[1,] <- rep(0, ncol(X))
for(it in 2:its) {
mat_beta[it,] <- p_beta(sig_sq = mat_sig[it-1])
mat_sig[it] <- p_sig(beta = mat_beta[it,])
}
list(mat_beta, mat_sig)
}
its <- 3000
a <- gibbs(its = its)
mat_beta <- a[[1]] #beta values
mat_sig <- a[[2]] #sig^2 values
list(mat_beta, mat_sig, X)
}
bayesian <- bayes_spline(c(0, 0.525, 0.865), y = y, x = x)
mat_beta <- bayesian[[1]]
mat_sig <- bayesian[[2]]
X <- bayesian[[3]]
burn <- 1:15
colMeans(mat_beta[-burn,]) #target: -1.83, 25.19, -91.23, 135.03
mean(mat_sig[-burn]) #target: 1.46
mean.pred <- X %*% t(mat_beta)
matplot(x, mean.pred, type = "l")
points(x,y)
pred <- t(mean.pred) + rnorm(300*2985,sd=sqrt(mat_sig)) #mean: X %*% beta
hist(X[100,] %*% t(mat_beta) + rnorm(2985,sd=sqrt(mat_sig))) #prediction
matplot(x,t(pred), type='l', col='lightgrey')
matplot(x,mean.pred, type='l', col='green', add=T)
points(x,y)
t1 <- 0.5 #knot at 0.5
s <- 1
B1 <- rep(NA, length(x))
for(i in 1:length(x)) {
B1[i] <- max(s * (x[i] - t1), 0)
}
mod <- lm(y ~ x + B1)
summary(mod)
cf <- mod$coefficients
sq <- x
hs <- sq - t1
hs[sq < t1] <- 0
yfit <- cf[1] + cf[2]*x + cf[3]*hs
plot(x,y, main = "Manual Basis Spline")
lines(x, yfit, type = "l", lwd = 5, col="navy")
source('~/Desktop/LANL/Git/LANL-CCS-6/Bayes_splines/mcmc_spline_rj.R')
det(diag(8))
source('~/Desktop/LANL/Git/LANL-CCS-6/Bayes_splines/mcmc_spline_rj.R')
factorial(4)
factorial
as.matrix(rep(9,9))
sample(c(1,2,3))
sample(c(1,2,3), 1)
sample(c(1,2,3), 1)
sample(c(1,2,3), 1)
sample(c(1,2,3), 1)
sample(c(1,2,3), 1, prob = 1/3)
sample(3, 1)
sample(3, 1)
sample(3, 1)
sample(3, 1)
rep(sample(3, 1), 100)
sample(3, 100)
sample(3, 100, replace = TRUE)
sample(3, 100, replace = TRUE)
sample(3, 100, replace = TRUE)
sample(3, 100, replace = TRUE)
sample(3, 100, replace = TRUE)
hist(sample(3, 10000, replace = TRUE))
hist(sample(3, 100, replace = TRUE))
hist(sample(3, 100, replace = TRUE))
hist(sample(3, 100, replace = TRUE))
hist(sample(3, 100, replace = TRUE))
knitr::opts_chunk$set(echo = TRUE)
n<-300
x<-seq(0,1,length.out=n)
y<-sin(2*pi*x^2)*10+rnorm(n)
plot(x,y)
knotnum <- 5
its = 3000
source("mcmc_spline_fixed.R")
res <- mcmc_spline(knotnum)
mat_beta <- res[[1]]
mat_sig <- res[[2]]
mat_t <- res[[3]]
X_curr <- res[[4]]
ar <- res[[5]]
mat_s <- res[[6]]
colMeans(mat_beta)
colMeans(mat_t)
mean(mat_sig)
ar
matplot(mat_beta, type = "l", main = "Plot of Regression Coefficients")
plot(mat_sig, type = "l", main = "Plot of Sigma^2")
matplot(mat_t, type = "l", main = "Plot of Knot Locations")
mean.pred <- matrix(NA, nrow = its, ncol = length(x))
pred <- mean.pred
for(p in 1:its) {
mean.pred[p,] <- spline.basis(nknot = knotnum, knots = mat_t[p,], signs = mat_s[p,]) %*% mat_beta[p,]
pred[p,] <- mean.pred[p,] + rnorm(length(x), sd = sqrt(mat_sig[p]))
}
mean.pred <- t(mean.pred)
pred_adj <- t(apply(pred, 2, quantile, probs = c(0.025, 0.975)))
matplot(x, pred_adj, col = "lightgrey", lwd = 6, type = "l")
matplot(x, mean.pred, type = "l", lwd = 3, add = TRUE)
points(x, y)
plot(x, rowMeans(mean.pred), lwd = 10, type = "l", col = "royalblue")
points(x, y)
sample(2:9, 1)
sample(2:9, 1)
sample(2:9, 1)
sample(2:9, 1)
sample(2:9, 1)
sample(2:9, 1)
sample(2:9, 1)
sample(2:9, 1)
knitr::opts_chunk$set(echo = TRUE)
set.seed(12)
n<-300
x<-seq(0,1,length.out=n)
y<-sin(2*pi*x^2)*10+rnorm(n)
plot(x,y)
generate_spline <- function(tvec, y, x, nknot = length(tvec)) {
s <- sample(c(1), nknot, replace = TRUE)
Bmat <- matrix(NA, nknot, length(x))
hs <- Bmat
for(i in 1:nknot) {
for(j in 1:length(x)) {
Bmat[i,j] <- max(s[i] * (x[j] - tvec[i]), 0)
} #creating basis functions
}
mBmat <- t(Bmat)
mod <- lm(y ~ mBmat) #use gibbs to sample coefs in bayes
pred <- predict(mod)
sq <- x
for(ii in 1:nknot) {
if(s[i] == 1) {
hs[ii,] <- sq - tvec[ii]
hs[ii,][sq < tvec[ii]] <- 0
}
else {
hs[ii,] <- -1*(sq - tvec[ii])
hs[ii,][sq < tvec[ii]] <- 0
}
} #setting x values
plot(x,y, main = "Manual Basis Spline")
lines(x, pred, type = "l", lwd = 5, col="blue1")
summary(mod)
}
tv <- c(0, 0.525, 0.865) #vector of t-values
generate_spline(tv, y = y, x = x)
knitr::opts_chunk$set(echo = TRUE)
set.seed(12)
n<-300
x<-seq(0,1,length.out=n)
y<-sin(2*pi*x^2)*10+rnorm(n)
plot(x,y)
generate_spline <- function(tvec, y, x, nknot = length(tvec)) {
s <- sample(c(1), nknot, replace = TRUE)
Bmat <- matrix(NA, nknot, length(x))
hs <- Bmat
for(i in 1:nknot) {
for(j in 1:length(x)) {
Bmat[i,j] <- max(s[i] * (x[j] - tvec[i]), 0)
} #creating basis functions
}
mBmat <- t(Bmat)
mod <- lm(y ~ mBmat) #use gibbs to sample coefs in bayes
pred <- predict(mod)
sq <- x
for(ii in 1:nknot) {
if(s[i] == 1) {
hs[ii,] <- sq - tvec[ii]
hs[ii,][sq < tvec[ii]] <- 0
}
else {
hs[ii,] <- -1*(sq - tvec[ii])
hs[ii,][sq < tvec[ii]] <- 0
}
} #setting x values
plot(x,y, main = "Manual Basis Spline")
lines(x, pred, type = "l", lwd = 5, col="blue1")
summary(mod)
}
tv <- c(0, 0.525, 0.865) #vector of t-values
generate_spline(tv, y = y, x = x)
library(mvtnorm)
bayes_spline <- function(tvec, y, x, nknot = length(tvec)) {
s <- sample(c(1), nknot, replace = TRUE)
Bmat <- matrix(NA, nknot, length(x))
hs <- Bmat
for(i in 1:nknot) {
for(j in 1:length(x)) {
Bmat[i,j] <- max(s[i] * (x[j] - tvec[i]), 0)
} #creating basis
} #X Matrix
X <- t(Bmat)
X <- cbind(1, X)
p_sig <- function(a = 0, b = 0, n = nrow(X), beta) {
a_term <- a + (n/2)
b_term <- 0.5 * (2*b + (t(y - (X %*% beta)) %*% (y - (X %*% beta)))) #y, X defined above
1 / rgamma(1, shape = a_term, rate = b_term)
}
p_beta <- function(sig_sq, tau_sq = 1000, p = ncol(X)-1) {
sig <- solve( (1/sig_sq) * (t(X) %*% X) + (1/tau_sq) * diag(p+1) )
mu <- (1/sig_sq) * sig %*% t(X) %*% y
rmvnorm(1, mean = mu, sigma = sig)
}
gibbs <- function(its) {
mat_beta <- matrix(NA, its, ncol(X))
mat_sig <- rep(NA, its)
mat_sig[1] <- 0.01
mat_beta[1,] <- rep(0, ncol(X))
for(it in 2:its) {
mat_beta[it,] <- p_beta(sig_sq = mat_sig[it-1])
mat_sig[it] <- p_sig(beta = mat_beta[it,])
}
list(mat_beta, mat_sig)
}
its <- 3000
a <- gibbs(its = its)
mat_beta <- a[[1]] #beta values
mat_sig <- a[[2]] #sig^2 values
list(mat_beta, mat_sig, X)
}
bayesian <- bayes_spline(c(0, 0.525, 0.865), y = y, x = x)
mat_beta <- bayesian[[1]]
mat_sig <- bayesian[[2]]
X <- bayesian[[3]]
burn <- 1:15
colMeans(mat_beta[-burn,]) #target: -1.83, 25.19, -91.23, 135.03
mean(mat_sig[-burn]) #target: 1.46
mean.pred <- X %*% t(mat_beta)
matplot(x, mean.pred, type = "l")
points(x,y)
pred <- t(mean.pred) + rnorm(300*2985,sd=sqrt(mat_sig)) #mean: X %*% beta
hist(X[100,] %*% t(mat_beta) + rnorm(2985,sd=sqrt(mat_sig))) #prediction
matplot(x,t(pred), type='l', col='lightgrey')
matplot(x,mean.pred, type='l', col='green', add=T)
points(x,y)
t1 <- 0.5 #knot at 0.5
s <- 1
B1 <- rep(NA, length(x))
for(i in 1:length(x)) {
B1[i] <- max(s * (x[i] - t1), 0)
}
mod <- lm(y ~ x + B1)
summary(mod)
cf <- mod$coefficients
sq <- x
hs <- sq - t1
hs[sq < t1] <- 0
yfit <- cf[1] + cf[2]*x + cf[3]*hs
plot(x,y, main = "Manual Basis Spline")
lines(x, yfit, type = "l", lwd = 5, col="navy")
knitr::opts_chunk$set(echo = TRUE)
set.seed(12)
n<-300
x<-seq(0,1,length.out=n)
y<-sin(2*pi*x^2)*10+rnorm(n)
plot(x,y)
generate_spline <- function(tvec, y, x, nknot = length(tvec)) {
s <- sample(c(1), nknot, replace = TRUE)
Bmat <- matrix(NA, nknot, length(x))
hs <- Bmat
for(i in 1:nknot) {
for(j in 1:length(x)) {
Bmat[i,j] <- max(s[i] * (x[j] - tvec[i]), 0)
} #creating basis functions
}
mBmat <- t(Bmat)
mod <- lm(y ~ mBmat) #use gibbs to sample coefs in bayes
pred <- predict(mod)
sq <- x
for(ii in 1:nknot) {
if(s[i] == 1) {
hs[ii,] <- sq - tvec[ii]
hs[ii,][sq < tvec[ii]] <- 0
}
else {
hs[ii,] <- -1*(sq - tvec[ii])
hs[ii,][sq < tvec[ii]] <- 0
}
} #setting x values
plot(x,y, main = "Manual Basis Spline")
lines(x, pred, type = "l", lwd = 5, col="blue1")
summary(mod)
}
tv <- c(0, 0.525, 0.865) #vector of t-values
generate_spline(tv, y = y, x = x)
library(mvtnorm)
bayes_spline <- function(tvec, y, x, nknot = length(tvec)) {
s <- sample(c(1), nknot, replace = TRUE)
Bmat <- matrix(NA, nknot, length(x))
hs <- Bmat
for(i in 1:nknot) {
for(j in 1:length(x)) {
Bmat[i,j] <- max(s[i] * (x[j] - tvec[i]), 0)
} #creating basis
} #X Matrix
X <- t(Bmat)
X <- cbind(1, X)
p_sig <- function(a = 0, b = 0, n = nrow(X), beta) {
a_term <- a + (n/2)
b_term <- 0.5 * (2*b + (t(y - (X %*% beta)) %*% (y - (X %*% beta)))) #y, X defined above
1 / rgamma(1, shape = a_term, rate = b_term)
}
p_beta <- function(sig_sq, tau_sq = 1000, p = ncol(X)-1) {
sig <- solve( (1/sig_sq) * (t(X) %*% X) + (1/tau_sq) * diag(p+1) )
mu <- (1/sig_sq) * sig %*% t(X) %*% y
rmvnorm(1, mean = mu, sigma = sig)
}
gibbs <- function(its) {
mat_beta <- matrix(NA, its, ncol(X))
mat_sig <- rep(NA, its)
mat_sig[1] <- 0.01
mat_beta[1,] <- rep(0, ncol(X))
for(it in 2:its) {
mat_beta[it,] <- p_beta(sig_sq = mat_sig[it-1])
mat_sig[it] <- p_sig(beta = mat_beta[it,])
}
list(mat_beta, mat_sig)
}
its <- 3000
a <- gibbs(its = its)
mat_beta <- a[[1]] #beta values
mat_sig <- a[[2]] #sig^2 values
list(mat_beta, mat_sig, X)
}
bayesian <- bayes_spline(c(0, 0.525, 0.865), y = y, x = x)
m3 <- lm(y ~ ns(x, knots = c(0.5, 0.82)), data = df)
s
x
max(0, x - 0.5)
pos <- function(vec) {
((abs(vec) + vec) / 2)
}
pos <- function(vec) {
((abs(vec) + vec) / 2)
}
adj <- x - 0.3
pos(adj)
pos <- function(vec) {
((abs(vec) + vec) / 2)
}
adj <- x - 0.3
plot(pos(adj))
pos <- function(vec) {
((abs(vec) + vec) / 2)
}
adj <- pos(x - 0.3)
plot(adj, type = "l")
pos <- function(vec) {
((abs(vec) + vec) / 2)
}
adj <- pos(x - 0.3)
plot(adj, type = "l", lwd = 3)
pos <- function(vec) {
((abs(vec) + vec) / 2)
}
adj <- pos(x - 0.3)
plot(adj, type = "l", lwd = 1)
pos <- function(vec) {
((abs(vec) + vec) / 2)
}
adj <- pos(x - 0.3)
plot(adj, type = "l", lwd = 2)
pos <- function(vec) {
((abs(vec) + vec) / 2)
}
adj <- pos(x - 0.3)
plot(adj, type = "l", lwd = 2, col = "blue1")
pos <- function(vec) {
((abs(vec) + vec) / 2)
}
adj <- pos(x - 0.3)
plot(adj, type = "l", lwd = 2, col = "blue2")
pos <- function(vec) {
((abs(vec) + vec) / 2)
}
adj <- pos(x - 0.3)
plot(adj, type = "l", lwd = 6, col = "blue2")
pos <- function(vec) {
((abs(vec) + vec) / 2)
}
adj <- pos(-(x - 0.3))
plot(adj, type = "l", lwd = 6, col = "blue2")
pos <- function(vec) {
((abs(vec) + vec) / 2)
}
adj1 <- pos(-(x - 0.3))
adj2 <- pos((x - 0.3))
plot(adj1, type = "l", lwd = 6, col = "blue2")
plot(adj2, type = "l", lwd = 6, col = "red2")
pos <- function(vec) {
((abs(vec) + vec) / 2)
}
adj1 <- pos(-(x - 0.9))
adj2 <- pos((x - 0.3))
plot(adj1, type = "l", lwd = 6, col = "blue2")
plot(adj2, type = "l", lwd = 6, col = "red2")
adj1 <- pos(-(x - 0.7))
pos <- function(vec) {
((abs(vec) + vec) / 2)
}
adj1 <- pos(-(x - 0.7))
adj2 <- pos((x - 0.3))
plot(adj1, type = "l", lwd = 6, col = "blue2")
plot(adj2, type = "l", lwd = 6, col = "red2")
m <- cbind(rep(1,3), rep(2,3), rep(3,3))
m
m <- cbind(m, rep(4, 3))
m
Xmat <- m
candidate_t <- c(0.9, 0.8, 0.7, 0.6)
unsign <- t(t(Xmat) - candidate_t)
unsign
basis_mat <- t(candidate_s * t(unsign))
candidate_s <- c(1,-1,1,-1)
basis_mat <- t(candidate_s * t(unsign))
basis_mat
pos <- function(vec) {
((abs(vec) + vec) / 2)
} # set anything less than 0 to 0; creating basis functions [a]+
pos(basis_mat)
knitr::opts_chunk$set(echo = TRUE)
n<-300
x<-seq(0,1,length.out=n)
y<-sin(2*pi*x^2)*10+rnorm(n)
plot(x,y)
set.seed(12)
source("mcmc_spline_rj.R")
iterations <- 3000
res <- mcmc_spline(its = iterations)
mat_beta <- res[[1]]
mat_beta <- mat_beta[,colSums(is.na(mat_beta)) != nrow(mat_beta)] %>% as.matrix()
mat_sig <- res[[2]]
mat_t <- res[[3]]
mat_t <- mat_t[,colSums(is.na(mat_t)) != nrow(mat_t)] %>% as.matrix()
mat_s <- res[[4]]
mat_s <- mat_s[,colSums(is.na(mat_s)) != nrow(mat_s)] %>% as.matrix()
X_curr <- res[[5]]
burn <- 1:50
matplot(mat_beta[-burn,], type = "l", main = "Plot of Regression Coefficients")
plot(mat_sig[-burn], type = "l", main = "Plot of Sigma^2")
matplot(mat_t, type = "l", main = "Plot of Knot Locations")
knotnum <- ncol(mat_t)
mean.pred <- matrix(NA, nrow = iterations, ncol = length(x))
pred <- mean.pred
for(p in 1:iterations) {
splb <- spline.basis(nknot = knotnum, knots = mat_t[p,], signs = mat_s[p,])
mean.pred[p,] <- splb %*% mat_beta[p,]
pred[p,] <- mean.pred[p,] + rnorm(length(x), sd = sqrt(mat_sig[p]))
}
mean.pred <- t(mean.pred)
pred_adj <- t(apply(pred, 2, quantile, probs = c(0.025, 0.975), na.rm = TRUE))
matplot(x, pred_adj, col = "lightgrey", lwd = 5, type = "l")
matplot(x, mean.pred, type = "l", lwd = 9, add = TRUE)
points(x, y)
plot(x, rowMeans(mean.pred, na.rm = TRUE), lwd = 8, type = "l", col = "royalblue")
points(x, y)
knotnum
