matplot(a[[1]], type = "l", main = "Plot of Beta vs. Iterations")
plot(a[[2]], type = "l", main = "Plot of sigma^2 vs. Iterations")
mod <- lm(y ~ ., data = dat2)
mod2 <- lm(y ~ 0 + X)
all(mod$coefficients == mod2$coefficients)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (nrow(X) - (ncol(X) - 1) - 1) #or just 1000 - 12
s_sq #same thing from summary table
summary(mod)$sigma^2 #from summary table
mean(a[[2]])
colMeans(a[[1]])
mod$coefficients
library(dplyr)
dat <- read.csv("data.csv")
dat2 <- dat[,-1]
y <- dat[,"y"]
X <- dat[,-c(1,2)] %>% as.matrix()
X <- cbind(1, X)
nrow(X) # n
ncol(X) # p = 11, p + 1 = 12
p_sig <- function(a = 1, b = 1, n = nrow(X), beta) {
a_term <- a + (n/2)
b_term <- 0.5 * (2*b + (t(y - (X %*% beta)) %*% (y - (X %*% beta)))) #y, X defined above
1 / rgamma(1, shape = a_term, rate = 1/b_term)
}
library(mvtnorm)
p_beta <- function(sig_sq, tau_sq = 1, p = ncol(X)) {
sig <- solve( (1/sig_sq) * (t(X) %*% X) + (1/tau_sq) * diag(p) )
mu <- (1/sig_sq) * sig %*% t(X) %*% y
rmvnorm(1, mean = mu, sigma = sig)
}
set.seed(12)
gibbs <- function(its, p = ncol(X)) {
mat_beta <- matrix(NA, its, p)
mat_sig <- rep(NA, its)
mat_sig[1] <- 1
mat_beta[1,] <- c(1, rep(0, p-1))
for(i in 2:its) {
mat_beta[i,] <- p_beta(sig_sq = mat_sig[i-1])
#browser()
mat_sig[i] <- p_sig(beta = mat_beta[i,])
}
list(mat_beta, mat_sig)
}
its <- 1000
a <- gibbs(its = its)
matplot(a[[1]], type = "l", main = "Plot of Beta vs. Iterations")
plot(a[[2]], type = "l", main = "Plot of sigma^2 vs. Iterations")
mod <- lm(y ~ ., data = dat2)
mod2 <- lm(y ~ 0 + X)
all(mod$coefficients == mod2$coefficients)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (nrow(X) - (ncol(X) - 1) - 1) #or just 1000 - 12
s_sq #same thing from summary table
summary(mod)$sigma^2 #from summary table
mean(a[[2]])
colMeans(a[[1]])
mod$coefficients
dat <- read.csv("data.csv")
dat2 <- dat[,-1]
dat2
library(dplyr)
dat <- read.csv("data.csv")
dat2 <- dat[,-1]
y <- dat$y
X <- dat[,-c(1,2)] %>% as.matrix()
X <- cbind(1, X)
nrow(X) # n
ncol(X) # p = 11, p + 1 = 12
y
library(dplyr)
dat <- read.csv("data.csv")
dat2 <- dat[,-1]
y <- dat$y
X <- dat[,-c(1,2)] %>% as.matrix()
X <- cbind(1, X)
nrow(X) # n
ncol(X) # p = 11, p + 1 = 12
X
library(dplyr)
dat <- read.csv("data.csv")
dat2 <- dat[,-1]
y <- dat$y
X <- dat[,-c(1,2)] %>% as.matrix()
X <- cbind(1, X)
nrow(X) # n
ncol(X) # p = 11, p + 1 = 12
library(dplyr)
dat <- read.csv("data.csv")
dat2 <- dat[,-1]
y <- dat$y
X <- dat[,-c(1,2)] %>% as.matrix()
X <- cbind(1, X)
nrow(X) # n
ncol(X) # p = 11, p + 1 = 12
p_sig <- function(a = 1, b = 1, n = nrow(X), beta) {
a_term <- a + (n/2)
b_term <- 0.5 * (2*b + (t(y - (X %*% beta)) %*% (y - (X %*% beta)))) #y, X defined above
1 / rgamma(1, shape = a_term, rate = 1/b_term)
}
library(mvtnorm)
p_beta <- function(sig_sq, tau_sq = 2, p = ncol(X)) {
sig <- solve( (1/sig_sq) * (t(X) %*% X) + (1/tau_sq) * diag(p) )
mu <- (1/sig_sq) * sig %*% t(X) %*% y
rmvnorm(1, mean = mu, sigma = sig)
}
set.seed(12)
gibbs <- function(its, p = ncol(X)) {
mat_beta <- matrix(NA, its, p)
mat_sig <- rep(NA, its)
mat_sig[1] <- 1
mat_beta[1,] <- c(1, rep(0, p-1))
for(i in 2:its) {
mat_beta[i,] <- p_beta(sig_sq = mat_sig[i-1])
#browser()
mat_sig[i] <- p_sig(beta = mat_beta[i,])
}
list(mat_beta, mat_sig)
}
its <- 1000
a <- gibbs(its = its)
matplot(a[[1]], type = "l", main = "Plot of Beta vs. Iterations")
plot(a[[2]], type = "l", main = "Plot of sigma^2 vs. Iterations")
mod <- lm(y ~ ., data = dat2)
mod2 <- lm(y ~ 0 + X) # same as above
all(mod$coefficients == mod2$coefficients)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (nrow(X) - (ncol(X) - 1) - 1) #or just 1000 - 12
s_sq #same thing from summary table
summary(mod)$sigma^2 #from summary table
mean(a[[2]])
colMeans(a[[1]])
mod$coefficients
mod <- lm(y ~ ., data = dat2)
mod2 <- lm(y ~ 0 + X) # same as above
all(mod$coefficients == mod2$coefficients)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (nrow(X) - (ncol(X) - 1) - 1) #or just 1000 - 12
s_sq #same thing from summary table
mean(a[[2]])
mod <- lm(y ~ 0 + X) # same as above
all(mod$coefficients == mod2$coefficients)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (nrow(X) - (ncol(X) - 1) - 1) #or just 1000 - 12
s_sq #same thing from summary table
mean(a[[2]])
colMeans(a[[1]])
mod$coefficients
table(colMeans(a[[1]]), mod$coefficients)
colMeans(a[[1]])
mod$coefficients
a[[1]]
a[[1]][nrow(data),]
colMeans(a[[1]])
a[[1]][nrow(data),]
mod$coefficients
nrow(data)
library(dplyr)
dat <- read.csv("data.csv")
dat2 <- dat[,-1]
y <- dat$y
X <- dat[,-c(1,2)] %>% as.matrix()
X <- cbind(1, X)
nrow(X) # n
ncol(X) # p = 11, p + 1 = 12
p_sig <- function(a = 1, b = 1, n = nrow(X), beta) {
a_term <- a + (n/2)
b_term <- 0.5 * (2*b + (t(y - (X %*% beta)) %*% (y - (X %*% beta)))) #y, X defined above
1 / rgamma(1, shape = a_term, rate = 1/b_term)
}
library(mvtnorm)
p_beta <- function(sig_sq, tau_sq = 1, p = ncol(X)) {
sig <- solve( (1/sig_sq) * (t(X) %*% X) + (1/tau_sq) * diag(p) )
mu <- (1/sig_sq) * sig %*% t(X) %*% y
rmvnorm(1, mean = mu, sigma = sig)
}
set.seed(12)
gibbs <- function(its, p = ncol(X)) {
mat_beta <- matrix(NA, its, p)
mat_sig <- rep(NA, its)
mat_sig[1] <- 1
mat_beta[1,] <- c(1, rep(0, p-1))
for(i in 2:its) {
mat_beta[i,] <- p_beta(sig_sq = mat_sig[i-1])
#browser()
mat_sig[i] <- p_sig(beta = mat_beta[i,])
}
list(mat_beta, mat_sig)
}
its <- 1000
a <- gibbs(its = its)
matplot(a[[1]], type = "l", main = "Plot of Beta vs. Iterations")
plot(a[[2]], type = "l", main = "Plot of sigma^2 vs. Iterations")
mod <- lm(y ~ 0 + X) # same as above
all(mod$coefficients == mod2$coefficients)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (nrow(X) - (ncol(X) - 1) - 1) #or just 1000 - 12
s_sq #same thing from summary table
mean(a[[2]])
colMeans(a[[1]])
a[[1]][nrow(data),]
mod$coefficients
colMeans(a[[1]])
a[[1]][nrow(X),]
mod$coefficients
library(dplyr)
dat <- read.csv("data.csv")
dat2 <- dat[,-1]
y <- dat$y
X <- dat[,-c(1,2)] %>% as.matrix()
X <- cbind(1, X)
n <- nrow(X) # n
p <- ncol(X) - 1# p = 11, p + 1 = 12
p_sig <- function(a = 1, b = 1, n = nrow(X), beta) {
a_term <- a + (n/2)
b_term <- 0.5 * (2*b + (t(y - (X %*% beta)) %*% (y - (X %*% beta)))) #y, X defined above
1 / rgamma(1, shape = a_term, rate = 1/b_term)
}
library(mvtnorm)
p_beta <- function(sig_sq, tau_sq = 1, p = ncol(X)) {
sig <- solve( (1/sig_sq) * (t(X) %*% X) + (1/tau_sq) * diag(p) )
mu <- (1/sig_sq) * sig %*% t(X) %*% y
rmvnorm(1, mean = mu, sigma = sig)
}
set.seed(12)
gibbs <- function(its, p = ncol(X)) {
mat_beta <- matrix(NA, its, p)
mat_sig <- rep(NA, its)
mat_sig[1] <- 1
mat_beta[1,] <- c(1, rep(0, p-1))
for(i in 2:its) {
mat_beta[i,] <- p_beta(sig_sq = mat_sig[i-1])
#browser()
mat_sig[i] <- p_sig(beta = mat_beta[i,])
}
list(mat_beta, mat_sig)
}
its <- 1000
a <- gibbs(its = its)
library(dplyr)
dat <- read.csv("data.csv")
dat2 <- dat[,-1]
y <- dat$y
X <- dat[,-c(1,2)] %>% as.matrix()
X <- cbind(1, X)
n <- nrow(X) # n
p <- ncol(X) - 1# p = 11, p + 1 = 12
p_sig <- function(a = 1, b = 1, n = nrow(X), beta) {
a_term <- a + (n/2)
b_term <- 0.5 * (2*b + (t(y - (X %*% beta)) %*% (y - (X %*% beta)))) #y, X defined above
1 / rgamma(1, shape = a_term, rate = 1/b_term)
}
library(mvtnorm)
p_beta <- function(sig_sq, tau_sq = 1, p = ncol(X)) {
sig <- solve( (1/sig_sq) * (t(X) %*% X) + (1/tau_sq) * diag(p) )
mu <- (1/sig_sq) * sig %*% t(X) %*% y
rmvnorm(1, mean = mu, sigma = sig)
}
set.seed(12)
gibbs <- function(its) {
mat_beta <- matrix(NA, its, p+1)
mat_sig <- rep(NA, its)
mat_sig[1] <- 1
mat_beta[1,] <- c(1, rep(0, p))
for(i in 2:its) {
mat_beta[i,] <- p_beta(sig_sq = mat_sig[i-1])
#browser()
mat_sig[i] <- p_sig(beta = mat_beta[i,])
}
list(mat_beta, mat_sig)
}
its <- 1000
a <- gibbs(its = its)
matplot(a[[1]], type = "l", main = "Plot of Beta vs. Iterations")
plot(a[[2]], type = "l", main = "Plot of sigma^2 vs. Iterations")
mod <- lm(y ~ 0 + X) # same as above
all(mod$coefficients == mod2$coefficients)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (nrow(X) - (ncol(X) - 1) - 1) #or just 1000 - 12
s_sq #same thing from summary table
mean(a[[2]])
colMeans(a[[1]])
a[[1]][nrow(X),]
mod$coefficients
library(dplyr)
dat <- read.csv("data.csv")
dat2 <- dat[,-1]
y <- dat$y
X <- dat[,-c(1,2)] %>% as.matrix()
X <- cbind(1, X)
n <- nrow(X) # n
p <- ncol(X) - 1# p = 11, p + 1 = 12
library(dplyr)
dat <- read.csv("data.csv")
y <- dat$y
X <- dat[,-c(1,2)] %>% as.matrix()
X <- cbind(1, X)
n <- nrow(X) # n
p <- ncol(X) - 1# p = 11, p + 1 = 12
p_sig <- function(a = 1, b = 1, n = nrow(X), beta) {
a_term <- a + (n/2)
b_term <- 0.5 * (2*b + (t(y - (X %*% beta)) %*% (y - (X %*% beta)))) #y, X defined above
1 / rgamma(1, shape = a_term, rate = 1/b_term)
}
library(mvtnorm)
p_beta <- function(sig_sq, tau_sq = 1, p = ncol(X)) {
sig <- solve( (1/sig_sq) * (t(X) %*% X) + (1/tau_sq) * diag(p) )
mu <- (1/sig_sq) * sig %*% t(X) %*% y
rmvnorm(1, mean = mu, sigma = sig)
}
set.seed(12)
gibbs <- function(its) {
mat_beta <- matrix(NA, its, p+1)
mat_sig <- rep(NA, its)
mat_sig[1] <- 1
mat_beta[1,] <- c(1, rep(0, p))
for(i in 2:its) {
mat_beta[i,] <- p_beta(sig_sq = mat_sig[i-1])
#browser()
mat_sig[i] <- p_sig(beta = mat_beta[i,])
}
list(mat_beta, mat_sig)
}
its <- 1000
a <- gibbs(its = its)
mat_beta <- a[[1]]
mat_sig <- a[[2]]
mod <- lm(y ~ 0 + X) # same as above
all(mod$coefficients == mod2$coefficients)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (nrow(X) - (ncol(X) - 1) - 1) #or just 1000 - 12
s_sq #same thing from summary table
mean(mat_sig)
mod <- lm(y ~ X) # same as above
all(mod$coefficients == mod2$coefficients)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (nrow(X) - (ncol(X) - 1) - 1) #or just 1000 - 12
s_sq #same thing from summary table
mean(mat_sig)
mod <- lm(y ~ 0 + X) # same as above
all(mod$coefficients == mod2$coefficients)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (nrow(X) - (ncol(X) - 1) - 1) #or just 1000 - 12
s_sq #same thing from summary table
mean(mat_sig)
colMeans(a[[1]])
a[[1]][n,]
mod$coefficients
mat_beta[n,]
mod$coefficients
colMeans(mat_beta)
mod$coefficients
mod <- lm(y ~ 0 + X)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (n - p - 1) #or just 1000 - 12
s_sq
mean(mat_sig)
colMeans(mat_beta)
mod$coefficients
mod <- lm(y ~ 0 + X)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (n - p - 1) #or just 1000 - 12
sqrt(s_sq)
mean(mat_sig)
mod <- lm(y ~ 0 + X)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (n - p - 1) #or just 1000 - 12
s_sq
mean(mat_sig)
library(dplyr)
dat <- read.csv("data.csv")
y <- dat$y
X <- dat[,-c(1,2)] %>% as.matrix()
X <- cbind(1, X)
n <- nrow(X) # n
p <- ncol(X) - 1# p = 11, p + 1 = 12
p_sig <- function(a = 1, b = 1, n = nrow(X), beta) {
a_term <- a + (n/2)
b_term <- 0.5 * (2*b + (t(y - (X %*% beta)) %*% (y - (X %*% beta)))) #y, X defined above
1 / rgamma(1, shape = a_term, rate = 1/b_term)
}
library(mvtnorm)
p_beta <- function(sig_sq, tau_sq = 1, p = ncol(X)) {
sig <- solve( (1/sig_sq) * (t(X) %*% X) + (1/tau_sq) * diag(p) )
mu <- (1/sig_sq) * sig %*% t(X) %*% y
rmvnorm(1, mean = mu, sigma = sig)
}
set.seed(12)
gibbs <- function(its) {
mat_beta <- matrix(NA, its, p+1)
mat_sig <- rep(NA, its)
mat_sig[1] <- 1
mat_beta[1,] <- rep(0, p+1)
for(i in 2:its) {
mat_beta[i,] <- p_beta(sig_sq = mat_sig[i-1])
mat_sig[i] <- p_sig(beta = mat_beta[i,])
}
list(mat_beta, mat_sig)
}
its <- 1000
a <- gibbs(its = its)
mat_beta <- a[[1]]
mat_sig <- a[[2]]
matplot(mat_beta, type = "l", main = "Plot of Beta vs. Iterations")
plot(mat_sig, type = "l", main = "Plot of sigma^2 vs. Iterations")
mod <- lm(y ~ 0 + X)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (n - p - 1) #or just 1000 - 12
s_sq
mean(mat_sig)
colMeans(mat_beta)
mod$coefficients
mod <- lm(y ~ X)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (n - p - 1) #or just 1000 - 12
s_sq
mean(mat_sig)
colMeans(mat_beta)
mod$coefficients
mod <- lm(y ~ 0 + X)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (n - p - 1) #or just 1000 - 12
s_sq
mean(mat_sig)
colMeans(mat_beta)
mod$coefficients
X
library(dplyr)
dat <- read.csv("data.csv")
y <- dat$y
X <- dat[,-c(1,2)] %>% as.matrix()
X <- cbind(1, X)
n <- nrow(X) # n
p <- ncol(X) - 1# p = 11, p + 1 = 12
p_sig <- function(a = 1, b = 1, n = nrow(X), beta) {
a_term <- a + (n/2)
b_term <- 0.5 * (2*b + (t(y - (X %*% beta)) %*% (y - (X %*% beta)))) #y, X defined above
1 / rgamma(1, shape = a_term, rate = 1/b_term)
}
library(mvtnorm)
p_beta <- function(sig_sq, tau_sq = 1, p = ncol(X)) {
sig <- solve( (1/sig_sq) * (t(X) %*% X) + (1/tau_sq) * diag(p) )
mu <- (1/sig_sq) * sig %*% t(X) %*% y
rmvnorm(1, mean = mu, sigma = sig)
}
set.seed(12)
gibbs <- function(its) {
mat_beta <- matrix(NA, its, p+1)
mat_sig <- rep(NA, its)
mat_sig[1] <- 0.001
mat_beta[1,] <- rep(0, p+1)
for(i in 2:its) {
mat_beta[i,] <- p_beta(sig_sq = mat_sig[i-1])
mat_sig[i] <- p_sig(beta = mat_beta[i,])
}
list(mat_beta, mat_sig)
}
its <- 1000
a <- gibbs(its = its)
mat_beta <- a[[1]]
mat_sig <- a[[2]]
matplot(mat_beta, type = "l", main = "Plot of Beta vs. Iterations")
plot(mat_sig, type = "l", main = "Plot of sigma^2 vs. Iterations")
mod <- lm(y ~ 0 + X)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (n - p - 1) #or just 1000 - 12
s_sq
mean(mat_sig)
mod <- lm(y ~ 0 + X)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (n - p - 1) %>% as.vector()#or just 1000 - 12
s_sq
mean(mat_sig)
mod <- lm(y ~ 0 + X)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (n - p - 1) %>% as.vector()#or just 1000 - 12
s_sq[,,drop = TRUE]
mean(mat_sig)
mod <- lm(y ~ 0 + X)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (n - p - 1)[,,drop = TRUE]#or just 1000 - 12
mod <- lm(y ~ 0 + X)
res <- mod$residuals
S_beta <- t(res) %*% res
s_sq <- S_beta / (n - p - 1)#or just 1000 - 12
s_sq[,,drop = TRUE]
mean(mat_sig)
source('~/Desktop/LANL/Git/LANL-CCS-6/MCMC/mcmc_gibbs_script.R')
install.packages("splines")
library(splines)
bs
?bs
